@c This is part of the GNU Octave Interval Package Manual.
@c Copyright (C) 2015 Oliver Heimlich.
@c See the file manual.texinfo for copying conditions.
@documentencoding UTF-8

This chapter gives a quick overview on the interval packages basic capabilities.  More detailed information can usually be found in the functions' documentation.


@section Input and Output

Before exercising interval arithmetic, interval objects must be created from non-interval data. There are interval constants @command{empty} and @command{entire} and the interval constructors @command{infsupdec} (create an interval from boundaries), @command{midrad} (create an interval from midpoint and radius) and @command{hull} (create an interval enclosure for a list of mixed arguments: numbers, intervals or interval literals). The constructors are very sophisticated and can be used with several kinds of parameters: Interval boundaries can be given by numeric values or string values with decimal numbers. 

Create intervals for performing interval arithmetic 
@example
@group
## Interval with a single number
infsupdec (1)
  @result{} ans = [1]_com
@end group
@end example
@example
@group
## Interval defined by lower and upper bound
infsupdec (1, 2)
  @result{} ans = [1, 2]_com
@end group
@end example
@example
@group
## Boundaries are converted from strings
infsupdec ("3", "4")
  @result{} ans = [3, 4]_com
@end group
@end example
@example
@group
## Decimal number
infsupdec ("1.1")
  @result{} ans ⊂ [1.0999999999999998, 1.100000000000001]_com
@end group
@end example
@example
@group
## Decimal number with scientific notation
infsupdec ("5.8e-17")
  @result{} ans ⊂ [5.799999999999999e-17, 5.800000000000001e-17]_com
@end group
@end example
@example
@group
## Interval around 12 with uncertainty of 3
midrad (12, 3)
  @result{} ans = [9, 15]_com
@end group
@end example
@example
@group
## Again with decimal numbers
midrad ("4.2", "1e-7")
  @result{} ans ⊂ [4.199999899999999, 4.200000100000001]_com
@end group
@end example
@example
@group
## Interval members with arbitrary order
hull (3, 42, "19.3", "-2.3")
  @result{} ans ⊂ [-2.300000000000001, +42]_com
@end group
@end example
@example
@group
## Symbolic numbers
hull ("pi", "e")
  @result{} ans ⊂ [2.718281828459045, 3.1415926535897936]_com
@end group
@end example

@strong{Warning:} In above examples decimal fractions are passed as a string to the constructor.  Otherwise it is possible, that GNU Octave introduces conversion errors when the numeric literal is converted into a floating-point number @emph{before} it is passed to the constructor.  The interval construction is a critical process, but after this the interval package takes care of any further conversion errors, representational errors, round-off errors and inaccurate numeric functions.

Beware of the conversion pitfall 
@example
@group
## The numeric constant 0.3 is an approximation of the
## decimal number 0.3.  An interval around this approximation
## will not contain the decimal number 0.3.
infsupdec (0.3)
  @result{} ans ⊂ [0.29999999999999998, 0.29999999999999999]_com
@end group
@end example
@example
@group
## However, passing the decimal number 0.3 as a string
## to the interval constructor will create an interval which
## actually encloses the decimal number.
infsupdec ("0.3")
  @result{} ans ⊂ [0.29999999999999998, 0.3000000000000001]_com
@end group
@end example

For maximum portability it is recommended to use interval literals, which are standardized by IEEE 1788.  Both interval boundaries are then given as a string in the form @code{[@var{l}, @var{u}]}.  The output in the examples above gives examples of several interval literals.

@example
@group
## Interval literal
infsupdec ("[20, 42e9]")
  @result{} ans = [20, 42000000000]_com
@end group
@end example

The default text representation of intervals is not guaranteed to be exact, because this would massively spam console output. For example, the exact text representation of @code{realmin} would be over 700 decimal places long! However, the output is correct as it guarantees to contain the actual boundaries: a displayed lower (upper) boundary is always less (greater) than or equal to the actual boundary.



@subsection Interval Vectors and Matrices

Vectors and matrices of intervals can be created by passing numerical matrices, string or cell arrays to the interval constructors. With cell arrays it is also possible to mix several types of boundaries.

Interval matrices behave like normal matrices in GNU Octave and can be used for broadcasting and vectorized function evaluation.  Vectorized function evaluation usually is the key to create very fast programs.

Create interval matrices
@example
@group
M = infsupdec (magic (3))
  @result{} M = 3×3 interval matrix
  
    [8]_com   [1]_com   [6]_com
    [3]_com   [5]_com   [7]_com
    [4]_com   [9]_com   [2]_com
@end group
@end example
@example
@group
infsupdec (magic (3), magic (3) + 1)
  @result{} ans = 3×3 interval matrix
  
    [8, 9]_com    [1, 2]_com   [6, 7]_com
    [3, 4]_com    [5, 6]_com   [7, 8]_com
    [4, 5]_com   [9, 10]_com   [2, 3]_com
@end group
@end example
@example
@group
infsupdec ("0.1; 0.2; 0.3; 0.4; 0.5")
  @result{} ans ⊂ 5×1 interval vector
  
    [0.09999999999999999, 0.1000000000000001]_com
    [0.19999999999999998, 0.2000000000000001]_com
    [0.29999999999999998, 0.3000000000000001]_com
    [0.39999999999999996, 0.4000000000000001]_com
                                        [0.5]_com
@end group
@end example
@example
@group
infsupdec ("1 [2, 3]; 4, 5, 6")
  @result{} ans = 2×3 interval matrix
  
    [1]_com   [2, 3]_com   [Empty]_trv
    [4]_com      [5]_com       [6]_com
@end group
@end example
@example
@group
infsupdec (@{1; eps; "4/7"; "pi"@}, @{2; 1; "e"; "0xff"@})
  @result{} ans ⊂ 4×1 interval vector
  
                                     [1, 2]_com
                 [2.220446049250313e-16, 1]_com
   [0.5714285714285713, 2.7182818284590456]_com
                   [3.141592653589793, 255]_com
@end group
@end example


@section Arithmetic Operations

The interval package comprises many interval arithmetic operations. A complete list can be found in its function reference. Function names match GNU Octave standard functions where applicable and follow recommendations by IEEE 1788 otherwise, @pxref{Function Names}.

The interval arithmetic flavor used by this package is the “set-based” interval arithmetic and follows these rules: Intervals are sets. They are subsets of the set of real numbers. The interval version of an elementary function such as sin(x) is essentially the natural extension to sets of the corresponding point-wise function on real numbers. That is, the function is evaluated for each number in the interval where the function is defined and the result must be an enclosure of all possible values that may occur.

By default arithmetic functions are computed with best possible accuracy (which is more than what is guaranteed by GNU Octave core functions). The result will therefore be a tight and very accurate enclosure of the true mathematical value in most cases. Details on each function's accuracy can be found in its documentation, which is accessible with GNU Octave's @command{help} command. 

Examples of using interval arithmetic functions
@example
@group
sin (infsupdec (0.5))
  @result{} ans ⊂ [0.4794255386042029, 0.4794255386042031]_com
@end group
@end example
@example
@group
power (infsupdec (2), infsupdec (3, 4))
  @result{} ans = [8, 16]_com
@end group
@end example
@example
@group
atan2 (infsupdec (1), infsupdec (1))
  @result{} ans ⊂ [0.7853981633974482, 0.7853981633974484]_com
@end group
@end example
@example
@group
midrad (magic (3), 0.5) * pascal (3)
  @result{} ans = 3×3 interval matrix
  
    [13.5, 16.5]_com   [25, 31]_com   [42, 52]_com
    [13.5, 16.5]_com   [31, 37]_com   [55, 65]_com
    [13.5, 16.5]_com   [25, 31]_com   [38, 48]_com
@end group
@end example


@section Numerical Operations

Some interval functions do not return an interval enclosure, but a single number (in binary64 precision). Most important are @command{inf} and @command{sup}, which return the lower and upper interval boundaries.

More such operations are @command{mid} (approximation of the interval's midpoint), @command{wid} (approximation of the interval's width), @command{rad} (approximation of the interval's radius), @command{mag} (interval's magnitude) and @command{mig} (interval's mignitude). 

@example
@group
## Enclosure of the decimal number 0.1 is not exact
## and results in an interval with a small uncertainty.
wid (infsupdec ("0.1"))
  @result{} ans =    1.3878e-17
@end group
@end example


@section Boolean Operations

Interval comparison operations produce boolean results. While some comparisons are especially for intervals (subset, interior, ismember, isempty, disjoint, …) others are interval extensions of simple numerical comparison. For example, the less-or-equal comparison is mathematically defined as ∀a ∃b a ≤ b ∧ ∀b ∃a a ≤ b.

@example
@group
infsup (1, 3) <= infsup (2, 4)
  @result{} ans = 1
@end group
@end example


@section Matrix Operations

Above mentioned operations can also be applied element-wise to interval vectors and matrices. Many operations use vectorization techniques.

In addition, there are matrix operations on interval matrices. These operations comprise: dot product, matrix multiplication, vector sums (all with tightest accuracy), matrix inversion, matrix powers, and solving linear systems (the latter are less accurate). As a result of missing hardware / low-level library support and missing optimizations, these operations are relatively slow compared to familiar operations in floating-point arithmetic. 

Examples of using interval matrix functions
@example
@group
A = infsupdec ([1, 2, 3; 4, 0, 0; 0, 0, 1]);
A (2, 3) = "[0, 6]"
  @result{} A = 3×3 interval matrix
  
    [1]_com   [2]_com      [3]_com
    [4]_com   [0]_com   [0, 6]_com
    [0]_com   [0]_com      [1]_com
@end group
@end example
@example
@group
B = inv (A)
  @result{} B = 3×3 interval matrix
  
      [0]_trv     [0.25]_trv       [-1.5, 0]_trv
    [0.5]_trv   [-0.125]_trv   [-1.5, -0.75]_trv
      [0]_trv        [0]_trv             [1]_trv
@end group
@end example
@example
@group
A * B
  @result{} ans = 3×3 interval matrix
  
    [1]_trv   [0]_trv   [-1.5, +1.5]_trv
    [0]_trv   [1]_trv       [-6, +6]_trv
    [0]_trv   [0]_trv            [1]_trv
@end group
@end example
@example
@group
A = infsupdec (magic (3))
  @result{} A = 3×3 interval matrix
  
    [8]_com   [1]_com   [6]_com
    [3]_com   [5]_com   [7]_com
    [4]_com   [9]_com   [2]_com
@end group
@end example
@example
@group
c = A \ [3; 4; 5]
  @result{} c ⊂ 3×1 interval vector
  
    [0.18333333333333315, 0.18333333333333358]_trv
    [0.43333333333333318, 0.43333333333333346]_trv
    [0.18333333333333307, 0.18333333333333355]_trv
@end group
@end example
@example
@group
A * c
  @result{} ans ⊂ 3×1 interval vector
  
    [2.9999999999999964, 3.0000000000000036]_trv
     [3.9999999999999964, 4.000000000000004]_trv
      [4.999999999999997, 5.000000000000003]_trv
@end group
@end example


@subsection Notes on Linear Systems

A system of linear equations in the form A@var{x} = b with intervals can be seen as a range of classical linear systems, which can be solved simultaneously. Whereas classical algorithms compute an approximation for a single solution of a single linear system, interval algorithms compute an enclosure for all possible solutions of (possibly several) linear systems. Some characteristics should definitely be known when linear interval systems are solved:

@itemize
@item
    If the linear system is underdetermined and has infinitely many solutions, the interval solution will be unbound in at least one of its coordinates. Contrariwise, from an unbound result it can not be concluded whether the linear system is underdetermined or has solutions.
@item
    If the interval result is empty in at least one of its coordinates, the linear system is guaranteed to be underdetermined and has no solutions. Contrariwise, from a non-empty result it can not be concluded whether all or some of the systems have solutions or not.
@item
    Wide intervals within the matrix A can easily lead to a superposition of cases, where the rank of A is no longer unique. If the linear interval system contains cases of linear independent equations as well as linear dependent equations, the resulting enclosure of solutions will inevitably be very broad.
@end itemize

However, solving linear systems with interval arithmetic can produce useful results in many cases and automatically carries a guarantee for error boundaries. Additionally, it can give better information than the floating-point variants for some cases. 


Standard floating point arithmetic versus interval arithmetic on ill-conditioned linear systems
@example
@group
A = [1, 0; 2, 0];
## This linear system has no solutions
A \ [3; 0]
  @result{} warning: matrix singular to machine precision, rcond = 0
    ans =
    
       0.60000
       0.00000
@end group
@end example
@example
@group
## This linear system has many solutions
A \ [4; 8]
  @result{} ans =
  
       4
       0
@end group
@end example

@example
@group
## The empty interval vector proves that there is no solution
infsup (A) \ [3; 0]
  @result{} ans = 2×1 interval vector
  
       [Empty]
       [Empty]
@end group
@end example
@example
@group
## The unbound interval vector indicates
## that there may be many solutions
infsup (A) \ [4; 8]
  @result{} ans = 2×1 interval vector
  
            [4]
       [Entire]
@end group
@end example

