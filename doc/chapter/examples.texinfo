@c This is part of the GNU Octave Interval Package Manual.
@c Copyright (C) 2015 Oliver Heimlich.
@c See the file manual.texinfo for copying conditions.
@documentencoding UTF-8

This chapter presents some more or less exotic use cases for the interval package.


@section Floating-point numbers

Floating-point numbers are most commonly used in binary64 format, a.k.a. double precision.  Internally they are stored in the form @code{± @var{m} * 2 ^ @var{e}} with some integral mantissa @var{m} and exponent @var{e}.  Most decimal fractions can only be stored approximately in this format.

The @funref{@@infsup/intervaltotext} function can be used to output the approximate value up to the last decimal digit.

@example
@group
intervaltotext (infsup (0.1), "exact decimal")
  @result{} ans = [0.1000000000000000055511151231257827021181583404541015625]
@end group
@end example

It can be seen that 0.1 is converted into the most accurate floating-point number.  In this case that value is greater than 0.1.  The next lower value can be seen after producing an interval enclosure around 0.1 with the nearest floating-point numbers in each direction.

@example
@group
intervaltotext (infsup ("0.1"), "exact decimal")
  @result{} ans =
    [0.09999999999999999167332731531132594682276248931884765625,
     0.1000000000000000055511151231257827021181583404541015625]
@end group
@end example

The error of this approximation can be examined with the @funref{@@infsup/wid} function.

@example
@group
wid (infsup ("0.1"))
  @result{} ans =    1.3878e-17
@end group
@end example

With the @funref{@@infsup/nextout} function an interval can be enlarged in each direction up to the next floating-point number.  Around zero the distance towards the next floating point number is very small, but gets bigger for numbers of higher magnitude.

@example
@group
wid (nextout (infsup ([0, 1, 1e10, 1e100])))
  @result{} ans =

       9.8813e-324    3.3307e-16    3.8147e-06    3.8853e+84

@end group
@end example


@section Parameter estimation

Consider the model @code{y (@var{t}) = @var{p1} * exp (@var{p2} * t)}.  The parameters @var{p1} and @var{p2} are unknown, but it is known that the model fulfills the following constraints, which have been obtained using measurements with known error bounds.

@display
@verbatim
p1, p2  ∈   [-3, 3]
y (0.2) ∈  [1.5, 2]
y (1)   ∈  [0.7, 0.8]
y (2)   ∈  [0.1, 0.3]
y (4)   ∈ [-0.1, 0.03]
@end verbatim
@end display

A better enclosure of the parameters @var{p1} and @var{p2} can be estimated with the @funref{@@infsup/fsolve} function.

@example
@group
y = @@(p1, p2, t) p1 .* exp (p2 .* t);
f = @@(p1, p2) y (p1, p2, [0.2; 1; 2; 4]);
p = fsolve (f, infsup ("[-3, 3] [-3, 3]")', ...
               infsup ("[1.5, 2] [0.7, 0.8] [0.1, 0.3] [-0.1, 0.03]")')
  @result{} p ⊂ 2×1 interval vector

         [1.9863, 2.6075]
       [-1.3243, -1.0429]

@end group
@end example

The resulting @code{p} guarantees to contain all parameters @code{[@var{p1}; @var{p2}]} which satisfy all constraints on @var{y}. It is no surprise that @code{f (p)} intersects the constraints for @var{y}.

@example
@group
f (p(1), p(2))
  @result{} ans ⊂ 4×1 interval vector

            [1.5241, 2.1166]
          [0.52838, 0.91888]
          [0.14055, 0.32382]
       [0.0099459, 0.040216]

@end group
@end example


@section Finding root enclosures

Consider the function @code{f (@var{x}, @var{y}) = -(5*@var{y} - 20*@var{y}^3 + 16*@var{y}^5)^6 + (-(5*@var{x} - 20*@var{x}^3 + 16*@var{x}^5)^3 + 5*@var{y} - 20*@var{y}^3 + 16*@var{y}^5)^2}, which has several roots in the area @var{x}, @var{y} ∈ [-2, 2].

@myimage{image/poly-example-surf.m,Surface plot of @code{f (@var{x}, @var{y})} which shows a lot of roots for the function}

The function is particular difficult to compute with intervals, because its variables appear several times in the expression, which benefits overestimation from the dependency problem.  Computing root enclosures with the @funref{@@infsup/fsolve} function is unfeasible, because many bisections would be necessary until the algorithm terminates with a useful result.  It is possible to reduce the overestimation with the @funref{@@infsup/polyval} function to some degree, but since this function is quite costly to compute, it does not speed up the bisecting algorithm.

@example
@group
f = @@(x,y) ...
    -(5.*y - 20.*y.^3 + 16.*y.^5).^6 + ...
        (-(5.*x - 20.*x.^3 + 16.*x.^5).^3 + ...
           5.*y - 20.*y.^3 + 16.*y.^5).^2;
X = Y = infsup ("[-2, 2]");
has_roots = n = 1;
@end group
@group
for iter = 1 : 10
    ## Bisect
    [i,j] = ind2sub ([n,n], has_roots);
    X = infsup ([X.inf,X.inf,X.mid,X.mid],[X.mid,X.mid,X.sup,X.sup]);
    Y = infsup ([Y.inf,Y.mid,Y.inf,Y.mid],[Y.mid,Y.sup,Y.mid,Y.sup]); 
    ii = [2*(i-1)+1,2*(i-1)+2,2*(i-1)+1,2*(i-1)+2] ;
    jj = [2*(j-1)+1,2*(j-1)+1,2*(j-1)+2,2*(j-1)+2] ;
    has_roots = sub2ind ([2*n,2*n], ii, jj);
    n *= 2;
    
    ## Check if function value covers zero
    fval = f (X, Y);
    zero_contained = find (ismember (0, fval));
    
    ## Discard values without roots
    has_roots = has_roots(zero_contained);
    X = X(zero_contained);
    Y = Y(zero_contained);
endfor
@end group
@group
colormap gray
B = false (n);
B(has_roots) = true;
imagesc (B)
axis equal
axis off
@end group
@end example

@myimage{image/poly-example-roots-simple.m,Enclosures of roots for the function @code{f (@var{x}, @var{y})}}

Now we use the same algorithm with the same number of iterations, but also utilize the @emph{mean value theorem} to produce better enclosures of the function value with first order approximation of the function. The function is evaluated at the interval's midpoint and a range evaluation of the derivative can be used to produce an enclosure of possible function values.

@example
@group
f_dx = @@(x,y) ...
       -6.*(5 - 60.*x.^2 + 80.*x.^4) .* ...
           (5.*x - 20.*x.^3 + 16.*x.^5).^2 .* ...
           (-(5.*x - 20.*x.^3 + 16.*x.^5).^3 + ...
                5.*y - 20.*y.^3 + 16.*y.^5);
f_dy = @@(x,y) ...
       -6.*(5 - 60.*y.^2 + 80.*y.^4) .* ...
           (5.*y - 20.*y.^3 + 16.*y.^5).^5 + ...
       2.*(5 - 60.*y.^2 + 80.*y.^4) .* ...
          (-(5.*x - 20.*x.^3 + 16.*x.^5).^3 + ...
                5.*y - 20.*y.^3 + 16.*y.^5);
@end group
@group
for iter = 1 : 10
    @dots{}
    ## Check if function value covers zero
    fval1 = f (X, Y);
    fval2 = f (mid (X), mid (Y)) + ...
            (X - mid (X)) .* f_dx (X, Y) + ...
            (Y - mid (Y)) .* f_dy (X, Y);
    fval = intersect (fval1, fval2);
    @dots{}
endfor
@end group
@end example

By using the derivative, it is possible to reduce overestimation errors and achieve a much better convergence behavior.

@myimage{image/poly-example-roots-with-deriv.m,Enclosures of roots for the function @code{f (@var{x}, @var{y})}}
